use lalrpop_util::{ ErrorRecovery };
use codespan::{ ByteIndex, Span };

use std::str::FromStr;
use ast::*;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, &'static str>>);

match {
  "bool" => BOOL,
  "def" => DEF,
  "else" => ELSE,
  "false" => FALSE,
  "for" => FOR,
  "if" => IF,
  "int" => INT,
  r"(let|var)" => LET,
  "read" => READ,
  "return" => RETURN,
  r"(skip|continue)" => SKIP,
  r"(stop|break)" => STOP,
  "str" => STR,
  "true" => TRUE,
  "while" => WHILE,
  "write" => WRITE,

  "[" => OPEN_BRACKET,
  "]" => CLOSE_BRACKET,
  "(" => OPEN_PARENS,
  ")" => CLOSE_PARENS,
  "{" => OPEN_BRACE,
  "}" => CLOSE_BRACE,

  "," => COMMA,
  ":" => COLON,
  ";" => SEMICOLON,

  "+" => PLUS,
  "-" => MINUS,
  "*" => ASTERISK,
  "/" => SLASH,
  "%" => PERCENT,
  "=" => EQUAL,

  "<" => LESS,
  ">" => GREATER,

  "!" => EXCLAMATION,
  "?" => QUESTION,

  "&" => AMPERSAND,
  "|" => PIPE,
} else {
    _
}

Num: u64 = r"[0-9]+" => u64::from_str(<>).unwrap();
Id: String = r"[a-zA-Z_][a-zA-Z0-9_]*" => String::from(<>);
String_Litteral: String = <s:r#""[^"]*""#> => s[1..s.len()-1].to_string();

Var: Variable = {
    <l:@L> <i:Id> OPEN_BRACKET <e:Expr> CLOSE_BRACKET <r:@R> => {
        let location = Span::new(ByteIndex(l as u32), ByteIndex(r as u32));

        Variable::Array(i, e, location)
    },
    <l:@L> <i:Id> <r:@R> => {
        let location = Span::new(ByteIndex(l as u32), ByteIndex(r as u32));

        Variable::Single(i, location)
    }
};

Tier<Op, Next>: Box<Expr> = {
    <l:@L> <e1:Tier<Op, Next>> <o:Op> <e2:Next> <r:@R> => {
        let location = Span::new(ByteIndex(l as u32), ByteIndex(r as u32));

        Box::new(Expr::Op(e1, o, e2, location))
    },
    Next,
};

Comma<T>: Vec<T> = {
    <v:(<T> COMMA)*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

SemiColon<T>: Vec<T> = {
    <v:(<T> SEMICOLON)*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

Either<T, U>: (Option<T>, Option<U>) = {
    <T> => (Some(<>), None),
    <U> => (None, Some(<>)),
};

Term: Box<Expr> = {
    <l:@L> TRUE <r:@R> => {
        let location = Span::new(ByteIndex(l as u32), ByteIndex(r as u32));

        Box::new(Expr::True(location))
    },
    <l:@L> FALSE <r:@R> => {
        let location = Span::new(ByteIndex(l as u32), ByteIndex(r as u32));

        Box::new(Expr::False(location))
    },
    <l:@L> <n:Num> <r:@R> => {
        let location = Span::new(ByteIndex(l as u32), ByteIndex(r as u32));

        Box::new(Expr::Number(n, location))
    },
    <l:@L> <s:String_Litteral> <r:@R> => {
        let location = Span::new(ByteIndex(l as u32), ByteIndex(r as u32));

        Box::new(Expr::StringLitteral(s, location))
    },
    <l:@L> <v:Var> <r:@R> => {
        let location = Span::new(ByteIndex(l as u32), ByteIndex(r as u32));

        Box::new(Expr::Variable(v, location))
    },
    <l:@L> <i:Id> OPEN_PARENS <e:Comma<Expr>?> CLOSE_PARENS <r:@R> => {
        let location = Span::new(ByteIndex(l as u32), ByteIndex(r as u32));

        Box::new(Expr::Call(i, e, location))
    },
    OPEN_PARENS <Expr> CLOSE_PARENS,
};

NegativeOp: Opcode = MINUS => Opcode::Negative;
Negative: Box<Expr> = {
    <l:@L> <o:NegativeOp> <e:Term> <r:@R> => {
        let location = Span::new(ByteIndex(l as u32), ByteIndex(r as u32));

        Box::new(Expr::Right(o, e, location))
    },
    Term,
};

NotOp: Opcode = EXCLAMATION => Opcode::Not;
Not: Box<Expr> = {
    <l:@L> <o:NotOp> <e:Negative> <r:@R> => {
        let location = Span::new(ByteIndex(l as u32), ByteIndex(r as u32));

        Box::new(Expr::Right(o, e, location))
    },
    Negative,
};

FactorOp: Opcode = {
    ASTERISK => Opcode::Mul,
    SLASH => Opcode::Div,
    PERCENT => Opcode::Mod,
};
Factor = Tier<FactorOp, Not>;

LinearOp: Opcode = {
    PLUS => Opcode::Add,
    MINUS => Opcode::Sub,
};
Linear = Tier<LinearOp, Factor>;

LesserOp: Opcode = {
    LESS EQUAL => Opcode::LesserOrEqual,
    LESS => Opcode::Lesser,
};
Lesser = Tier<LesserOp, Linear>;

GreaterOp: Opcode = {
    GREATER EQUAL => Opcode::GreaterOrEqual,
    GREATER => Opcode::Greater,
};
Greater = Tier<GreaterOp, Lesser>;

EqualityOp: Opcode = {
    EQUAL EQUAL => Opcode::Equal,
    EXCLAMATION EQUAL => Opcode::Different,
};
Equality = Tier<EqualityOp, Greater>;

AndOp: Opcode = AMPERSAND AMPERSAND => Opcode::And;
And = Tier<AndOp, Equality>;

OrOp: Opcode = PIPE PIPE => Opcode::Or;
Or = Tier<OrOp, And>;

Ternary: Box<Expr> = {
    <l:@L> <p:Or> QUESTION <t:Or> COLON <e:Expr> <r:@R> => {
        let location = Span::new(ByteIndex(l as u32), ByteIndex(r as u32));

        Box::new(Expr::Ternary(p, t, e, location))
    },
    Or,
};

Expr = Ternary;

Type: Type = {
    INT => Type::Int,
    BOOL => Type::Bool,
    STR => Type::Str,
};

VarArrayDecl: (String, u64, Option<Vec<Box<Expr>>>, Span<ByteIndex>) = {
    <l:@L> <a:Id> OPEN_BRACKET <n:Num> CLOSE_BRACKET <r:@R> EQUAL OPEN_BRACE <f:Comma<Expr>> CLOSE_BRACE => {
        let location = Span::new(ByteIndex(l as u32), ByteIndex(r as u32));

        (a, n, Some(f), location)
    },
    <l:@L> <a:Id> OPEN_BRACKET <n:Num> CLOSE_BRACKET <r:@R> => {
        let location = Span::new(ByteIndex(l as u32), ByteIndex(r as u32));

        (a, n, None, location)
    }
};

VarSingleDecl: (String, Option<Box<Expr>>, Span<ByteIndex>) = {
    <l:@L> <i:Id> <r:@R> EQUAL <e:Expr> => {
        let location = Span::new(ByteIndex(l as u32), ByteIndex(r as u32));
        
        (i, Some(e), location)
    },
    <l:@L> <i:Id> <r:@R> => {
        let location = Span::new(ByteIndex(l as u32), ByteIndex(r as u32));

        (i, None, location)
    }
};

VarDeclList = Comma<Either<VarSingleDecl, VarArrayDecl>>;

VarDecl: Vec<Decl> = {
    LET <d:VarDeclList> COLON <t:Type> SEMICOLON => {
        let mut f = Vec::new();
        for i in d {
            if let Some(j) = i.0 {
                f.push(Decl::Single(j.0, t.clone(), j.1, j.2));
            } else if let Some(j) = i.1 {
                f.push(Decl::Array(j.0, t.clone(), j.1, j.2, j.3));
            }
        }
        f
    },
};

ParamArrayDecl: (String, Span<ByteIndex>) = {
    <l:@L> <i:Id> OPEN_BRACKET CLOSE_BRACKET <r:@R> => {
        let location = Span::new(ByteIndex(l as u32), ByteIndex(r as u32));

        (i, location)
    },
};

ParamSingleDecl: (String, Span<ByteIndex>) = {
    <l:@L> <i:Id> <r:@R> => {
        let location = Span::new(ByteIndex(l as u32), ByteIndex(r as u32));

        (i, location)
    },
};

ParamDeclList = Comma<Either<ParamSingleDecl, ParamArrayDecl>>;

FuncDecl: Decl = <l:@L> DEF <i:Id> OPEN_PARENS <p:SemiColon<(<ParamDeclList> COLON <Type>)>?> CLOSE_PARENS <t:(COLON <Type>)?> <r:@R> <b:Block> => {
    let mut parameters_vector = Vec::new();
    let location = Span::new(ByteIndex(l as u32), ByteIndex(r as u32));

    if let Some(parameter_list) = p {
        for parameter in parameter_list {
            // parameter is an tuple of (list, type)
            let ( declaration_list, type_of ) = parameter;
            for declaration in declaration_list {
                // !! The declaration is a parser Either not an AST::Either
                if let Some((identifier, location)) = declaration.0 { // If either is fullfiled in the left is a single variable
                    parameters_vector.push(FuncParam::Single(identifier, type_of.clone(), location));
                } else if let Some((identifier, location)) = declaration.1 { // Else if is fullfiled in the right side is an array
                    parameters_vector.push(FuncParam::Array(identifier, type_of.clone(), location));
                }
            }
        }
        // i -> identifier
        // t -> function return type, could be None, when it's a procedure
        // parameter_list -- Could be None, when it does not have any parameter
        // b -> function block
        Decl::Func(i, t, Some(parameters_vector), b, location) // When have parameters
    } else {
        Decl::Func(i, t, None, b, location) // When does not have parameter
    }
};

Decl: Vec<Decl> = {
    VarDecl => <>,
    FuncDecl => vec![<>],
};

Attr<O>: (Variable, Box<Expr>, Span<ByteIndex>)  = {
    <l:@L> <v:Var> <o:O> <e:Expr> <r:@R> => {
        let location = Span::new(ByteIndex(l as u32), ByteIndex(r as u32));

        (v.clone(), Box::new(Expr::Op(Box::new(Expr::Variable(v, location)), o, e, location)), location)
    }
};

AddEqual: Opcode = PLUS EQUAL => Opcode::Add;
SubEqual: Opcode = MINUS EQUAL => Opcode::Sub;
MulEqual: Opcode = ASTERISK EQUAL => Opcode::Mul;
DivEqual: Opcode = SLASH EQUAL => Opcode::Div;
ModEqual: Opcode = PERCENT EQUAL => Opcode::Mod;

AllAttr: Stmt = {
    <l:@L> <v:Var> EQUAL <e:Expr> <r:@R> => {
        let location = Span::new(ByteIndex(l as u32), ByteIndex(r as u32));

        Stmt::Attr(v, e, location)
    },
    <l:@L> <v:Var> PLUS PLUS <r:@R> => {
        let location = Span::new(ByteIndex(l as u32), ByteIndex(r as u32));
        
        Stmt::Attr(
            v.clone(),
            Box::new(
                Expr::Op(
                    Box::new(Expr::Variable(v, location)),
                    Opcode::Add,
                    Box::new(Expr::Number(1, location)),
                    location
                )
            ),
            location
        )
    },
    <l:@L> <v:Var> MINUS MINUS <r:@R> => {
        let location = Span::new(ByteIndex(l as u32), ByteIndex(r as u32));

        Stmt::Attr(
            v.clone(),
            Box::new(
                Expr::Op(
                    Box::new(Expr::Variable(v, location)),
                    Opcode::Sub,
                    Box::new(Expr::Number(1, location)),
                    location
                )
            ),
            location
        )
    },
    <a:Attr<AddEqual>> => Stmt::Attr(a.0, a.1, a.2),
    <a:Attr<SubEqual>> => Stmt::Attr(a.0, a.1, a.2),
    <a:Attr<MulEqual>> => Stmt::Attr(a.0, a.1, a.2),
    <a:Attr<DivEqual>> => Stmt::Attr(a.0, a.1, a.2),
    <a:Attr<ModEqual>> => Stmt::Attr(a.0, a.1, a.2),
};

Stmt: Stmt = {
    <AllAttr> SEMICOLON => <>,

    <l:@L> SKIP <r:@R> SEMICOLON => {
        let location = Span::new(ByteIndex(l as u32), ByteIndex(r as u32));

        Stmt::Skip(location)
    },
    <l:@L> STOP <r:@R> SEMICOLON => {
        let location = Span::new(ByteIndex(l as u32), ByteIndex(r as u32));

        Stmt::Stop(location)
    },
    <l:@L> RETURN <e:Expr?> <r:@R> SEMICOLON => {
        let location = Span::new(ByteIndex(l as u32), ByteIndex(r as u32));

        Stmt::Return(e, location)
    },
    <l:@L> READ <v:Var> <r:@R> SEMICOLON => {
        let location = Span::new(ByteIndex(l as u32), ByteIndex(r as u32));

        Stmt::Read(v, location)
    },
    <l:@L> WRITE <e:Comma<Expr>> <r:@R> SEMICOLON => {
        let location = Span::new(ByteIndex(l as u32), ByteIndex(r as u32));

        Stmt::Write(e, location)
    },
    <l:@L> <i:Id> OPEN_PARENS <e:Comma<Expr>?> CLOSE_PARENS <r:@R> SEMICOLON => {
        let location = Span::new(ByteIndex(l as u32), ByteIndex(r as u32));

        Stmt::Call(i, e, location)
    },
    <l:@L> IF OPEN_PARENS <e:Expr> CLOSE_PARENS <r:@R> <b:Block> <elifs:(ELSE IF OPEN_PARENS <Expr> CLOSE_PARENS <Block>)*> <e_block:(ELSE <Block>)?> => {
        let location = Span::new(ByteIndex(l as u32), ByteIndex(r as u32));

        Stmt::If(e, b, elifs, e_block, location)
    },
    <l:@L> WHILE OPEN_PARENS <e:Expr> CLOSE_PARENS <r:@R> <b:Block> => {
        let location = Span::new(ByteIndex(l as u32), ByteIndex(r as u32));

        Stmt::While(e, b, location)
    },
    <l:@L> FOR OPEN_PARENS <i:AllAttr> SEMICOLON <e:Expr> SEMICOLON <s:AllAttr> CLOSE_PARENS <r:@R> <b:Block> => {
        let location = Span::new(ByteIndex(l as u32), ByteIndex(r as u32));

        Stmt::For(Box::new(i), e, Box::new(s), b, location)
    }
};

Commands: Either<Stmt, Block> = {
    <Stmt> => Either::Left(<>),
    <Block> => Either::Right(<>),
};

Block: Block = OPEN_BRACE <d:Decl*> <c:Commands*> CLOSE_BRACE => {
    flatten!(d);
    Block::new(d, c)
};

pub Program: Vec<Decl> = <d:Decl+> => {
    flatten!(d);
    d
};
