use std::str::FromStr;
use ast::{Variable, Either, Block, Stmt, Expr, Opcode, Type, Decl};

grammar;

match {
    "bool" => BOOL,
    "def" => DEF,
    "else" => ELSE,
    "false" => FALSE,
    "for" => FOR,
    "if" => IF,
    "int" => INT,
    "let" => LET,
    "read" => READ,
    "return" => RETURN,
    "skip" => SKIP,
    "stop" => STOP,
    "str" => STR,
    "true" => TRUE,
    "while" => WHILE,
    "write" => WRITE,
} else {
    _
}

Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap(),
};

Id: String = r"[a-zA-Z_][a-zA-Z0-9_]*" => String::from(<>);

Var: Variable = {
    <Id> "[" <Num> "]" => Variable::Array(<>),
    <Id> => Variable::Id(<>),
};

Tier<Op, Next>: Box<Expr> = {
    Tier<Op, Next> Op Next => Box::new(Expr::Op(<>)),
    Next,
};

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

Term: Box<Expr> = {
    TRUE => Box::new(Expr::True),
    FALSE => Box::new(Expr::False),
    Num => Box::new(Expr::Number(<>)),
    Var => Box::new(Expr::Variable(<>)),
    "(" <Expr> ")",
};

NegativeOp: Opcode = "-" => Opcode::Negative;
Negative: Box<Expr> = {
    NegativeOp Term => Box::new(Expr::Right(<>)),
    Term,
};

NotOp: Opcode = "!" => Opcode::Not;
Not: Box<Expr> = {
    NotOp Negative=> Box::new(Expr::Right(<>)),
    Negative,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
    "%" => Opcode::Mod,
};
Factor = Tier<FactorOp, Not>;

LinearOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};
Linear = Tier<LinearOp, Factor>;

LesserOp: Opcode = {
    "<=" => Opcode::LesserOrEqual,
    "<" => Opcode::Lesser,
};
Lesser = Tier<LesserOp, Linear>;

GreaterOp: Opcode = {
    ">=" => Opcode::GreaterOrEqual,
    ">" => Opcode::Greater,
};
Greater = Tier<GreaterOp, Lesser>;

EqualityOp: Opcode = {
    "==" => Opcode::Equal,
    "!=" => Opcode::Different,
}
Equality = Tier<EqualityOp, Greater>;

AndOp: Opcode = "&&" => Opcode::And;
And = Tier<AndOp, Equality>;

OrOp: Opcode = "||" => Opcode::Or;
Or = Tier<OrOp, And>;

Ternary: Box<Expr> = {
    <Or> "?" <Or> ":" <Expr> => Box::new(Expr::Ternary(<>)),
    Or,
};

pub Expr = Ternary;

Type: Type = {
    INT => Type::Int,
    BOOL => Type::Bool,
    STR => Type::Str,
};

ArrayDecl: (String, i32, Option<Vec<Box<Expr>>>) = {
    <a:Id> "[" <n:Num> "]" "=" "{" <f:Comma<Expr>> "}" => (a, n, Some(f)),
    <a:Id> "[" <n:Num> "]" => (a, n, None),
};

SingleDecl: (String, Option<Box<Expr>>) = {
    <i:Id> "=" <e:Expr> => (i, Some(e)),
    <Id> => (<>, None),
};

Either<T, U>: (Option<T>, Option<U>) = {
    <T> => (Some(<>), None),
    <U> => (None, Some(<>)),
}

DeclList = Comma<Either<SingleDecl, ArrayDecl>>;

pub Decl: Vec<Decl> = {
    <l:(LET <DeclList> ":" <Type> ";")+> => {
        let mut f = Vec::new();
        for x in l {
            let d = x.0;
            let t = x.1;
            for i in d {
                if let Some(j) = i.0 {
                    f.push(Decl::Single(j.0, t.clone(), j.1));
                } else if let Some(j) = i.1 {
                    f.push(Decl::Array(j.0, t.clone(), j.1, j.2));
                }
            }
        }
        f
    },
};

Attr<O>: (Variable, Box<Expr>)  = {
    <v:Var> <o:O> <e:Expr> => (v.clone(), Box::new(Expr::Op(Box::new(Expr::Variable(v)), o, e))),
};

AddEqual: Opcode = "+=" => Opcode::Add;
SubEqual: Opcode = "-=" => Opcode::Add;
MulEqual: Opcode = "*=" => Opcode::Add;
DivEqual: Opcode = "/=" => Opcode::Add;
ModEqual: Opcode = "%=" => Opcode::Add;

AllAttr: Stmt = {
    <v:Var> "=" <e:Expr> => Stmt::Attr(v, e),
    <a:Attr<AddEqual>> => Stmt::Attr(a.0, a.1),
    <a:Attr<SubEqual>> => Stmt::Attr(a.0, a.1),
    <a:Attr<MulEqual>> => Stmt::Attr(a.0, a.1),
    <a:Attr<DivEqual>> => Stmt::Attr(a.0, a.1),
    <a:Attr<ModEqual>> => Stmt::Attr(a.0, a.1),
};

Stmt: Stmt = {
    <AllAttr> ";" => <>,

    SKIP ";" => Stmt::Skip,
    STOP ";" => Stmt::Stop,
    RETURN <Expr?> ";" => Stmt::Return(<>),

    READ <v:Var> ";" => Stmt::Read(<>),
    WRITE <Comma<Expr>> ";" => Stmt::Write(<>),

    <Id> "(" <Comma<Expr>?> ")" ";" => Stmt::Call(<>),

    IF "(" <Expr> ")" <Block> <(ELSE IF "(" <Expr> ")" <Block>)*> <(ELSE <Block>)?> => Stmt::If(<>),

    WHILE "(" <Expr> ")" <Block> => Stmt::While(<>),

    FOR "(" <i:AllAttr> ";" <e:Expr> ";" <s:AllAttr> ")" <b:Block> => Stmt::For(Box::new(i), e, Box::new(s), b),
};

pub Commands: Vec<Either<Stmt, Block>> = {
    <s:Stmt+> => {
        let mut c = Vec::new();
        for i in s {
            c.push(Either::Left(i));
        }
        c
    },
};

pub Block: Block = "{" <Decl?> <Commands?> "}" => Block::new(<>);
