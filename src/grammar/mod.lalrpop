use std::str::FromStr;
use ast::{FuncParam, Variable, Either, Block, Stmt, Expr, Opcode, Type, Decl};

grammar;

match {
    "bool" => BOOL,
    "def" => DEF,
    "else" => ELSE,
    "false" => FALSE,
    "for" => FOR,
    "if" => IF,
    "int" => INT,
    "let" => LET,
    "read" => READ,
    "return" => RETURN,
    "skip" => SKIP,
    "stop" => STOP,
    "str" => STR,
    "true" => TRUE,
    "while" => WHILE,
    "write" => WRITE,
} else {
    _
}

Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap(),
};

Id: String = r"[a-zA-Z_][a-zA-Z0-9_]*" => String::from(<>);

Var: Variable = {
    <Id> "[" <Num> "]" => Variable::Array(<>),
    <Id> => Variable::Id(<>),
};

Tier<Op, Next>: Box<Expr> = {
    Tier<Op, Next> Op Next => Box::new(Expr::Op(<>)),
    Next,
};

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

SemiColon<T>: Vec<T> = {
    <v:(<T> ";")*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};

Either<T, U>: (Option<T>, Option<U>) = {
    <T> => (Some(<>), None),
    <U> => (None, Some(<>)),
};

Term: Box<Expr> = {
    TRUE => Box::new(Expr::True),
    FALSE => Box::new(Expr::False),
    Num => Box::new(Expr::Number(<>)),
    Var => Box::new(Expr::Variable(<>)),
    "(" <Expr> ")",
};

NegativeOp: Opcode = "-" => Opcode::Negative;
Negative: Box<Expr> = {
    NegativeOp Term => Box::new(Expr::Right(<>)),
    Term,
};

NotOp: Opcode = "!" => Opcode::Not;
Not: Box<Expr> = {
    NotOp Negative=> Box::new(Expr::Right(<>)),
    Negative,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
    "%" => Opcode::Mod,
};
Factor = Tier<FactorOp, Not>;

LinearOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};
Linear = Tier<LinearOp, Factor>;

LesserOp: Opcode = {
    "<=" => Opcode::LesserOrEqual,
    "<" => Opcode::Lesser,
};
Lesser = Tier<LesserOp, Linear>;

GreaterOp: Opcode = {
    ">=" => Opcode::GreaterOrEqual,
    ">" => Opcode::Greater,
};
Greater = Tier<GreaterOp, Lesser>;

EqualityOp: Opcode = {
    "==" => Opcode::Equal,
    "!=" => Opcode::Different,
};
Equality = Tier<EqualityOp, Greater>;

AndOp: Opcode = "&&" => Opcode::And;
And = Tier<AndOp, Equality>;

OrOp: Opcode = "||" => Opcode::Or;
Or = Tier<OrOp, And>;

Ternary: Box<Expr> = {
    <Or> "?" <Or> ":" <Expr> => Box::new(Expr::Ternary(<>)),
    Or,
};

Expr = Ternary;

Type: Type = {
    INT => Type::Int,
    BOOL => Type::Bool,
    STR => Type::Str,
};

VarArrayDecl: (String, i32, Option<Vec<Box<Expr>>>) = {
    <a:Id> "[" <n:Num> "]" "=" "{" <f:Comma<Expr>> "}" => (a, n, Some(f)),
    <a:Id> "[" <n:Num> "]" => (a, n, None),
};

VarSingleDecl: (String, Option<Box<Expr>>) = {
    <i:Id> "=" <e:Expr> => (i, Some(e)),
    <Id> => (<>, None),
};

VarDeclList = Comma<Either<VarSingleDecl, VarArrayDecl>>;

VarDecl: Vec<Decl> = {
    LET <d:VarDeclList> ":" <t:Type> ";" => {
        let mut f = Vec::new();
        for i in d {
            if let Some(j) = i.0 {
                f.push(Decl::Single(j.0, t.clone(), j.1));
            } else if let Some(j) = i.1 {
                f.push(Decl::Array(j.0, t.clone(), j.1, j.2));
            }
        }
        f
    },
};

ParamArrayDecl: String = {
    <Id> "[" "]" => <>,
};

ParamSingleDecl: String = {
    <Id> => <>,
};

ParamDeclList = Comma<Either<ParamSingleDecl, ParamArrayDecl>>;

FuncDecl: Decl = DEF <i:Id> "(" <p:SemiColon<(<ParamDeclList> ":" <Type>)>> ")" <t:(":" <Type>)?> <b:Block> => {
    let mut v = Vec::new();
    for x in p {
        let d = x.0;
        let t = x.1;
        for i in d {
            if let Some(j) = i.0 {
                v.push(FuncParam::Single(j, t.clone()));
            } else if let Some(j) = i.1 {
                v.push(FuncParam::Array(j, t.clone()));
            }
        }
    }
    Decl::Func(i, t, v, b)
};

Decl: Vec<Decl> = {
    VarDecl => <>,
    FuncDecl => vec![<>],
};

Attr<O>: (Variable, Box<Expr>)  = {
    <v:Var> <o:O> <e:Expr> => (v.clone(), Box::new(Expr::Op(Box::new(Expr::Variable(v)), o, e))),
};

AddEqual: Opcode = "+=" => Opcode::Add;
SubEqual: Opcode = "-=" => Opcode::Add;
MulEqual: Opcode = "*=" => Opcode::Add;
DivEqual: Opcode = "/=" => Opcode::Add;
ModEqual: Opcode = "%=" => Opcode::Add;

AllAttr: Stmt = {
    <v:Var> "=" <e:Expr> => Stmt::Attr(v, e),
    <a:Attr<AddEqual>> => Stmt::Attr(a.0, a.1),
    <a:Attr<SubEqual>> => Stmt::Attr(a.0, a.1),
    <a:Attr<MulEqual>> => Stmt::Attr(a.0, a.1),
    <a:Attr<DivEqual>> => Stmt::Attr(a.0, a.1),
    <a:Attr<ModEqual>> => Stmt::Attr(a.0, a.1),
};

Stmt: Stmt = {
    <AllAttr> ";" => <>,

    SKIP ";" => Stmt::Skip,
    STOP ";" => Stmt::Stop,
    RETURN <Expr?> ";" => Stmt::Return(<>),

    READ <v:Var> ";" => Stmt::Read(<>),
    WRITE <Comma<Expr>> ";" => Stmt::Write(<>),

    <Id> "(" <Comma<Expr>?> ")" ";" => Stmt::Call(<>),

    IF "(" <Expr> ")" <Block> <(ELSE IF "(" <Expr> ")" <Block>)*> <(ELSE <Block>)?> => Stmt::If(<>),

    WHILE "(" <Expr> ")" <Block> => Stmt::While(<>),

    FOR "(" <i:AllAttr> ";" <e:Expr> ";" <s:AllAttr> ")" <b:Block> => Stmt::For(Box::new(i), e, Box::new(s), b),
};

Commands: Either<Stmt, Block> = {
    <Stmt> => Either::Left(<>),
    <Block> => Either::Right(<>),
};

pub Block: Block = "{" <d:Decl*> <c:Commands*> "}" => {
    let mut vd = Vec::new();
    for i in d {
        let mut i = i;
        vd.append(&mut i);
    }
    Block::new(vd, c)
};
